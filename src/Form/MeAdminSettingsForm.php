<?php

/**
 * @file
 * Contains \Drupal\me\Form\MeAdminSettingsForm.
 */

namespace Drupal\me\Form;

use Drupal\Core\Form\ConfigFormBase;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Render\Element;
use Drupal\token\Token;
use Drupal\token\TreeBuilderInterface;
use Symfony\Component\DependencyInjection\ContainerInterface;

class MeAdminSettingsForm extends ConfigFormBase {

  /**
   * @var \Drupal\token\TreeBuilderInterface
   */
  protected $treeBuilder;

  public function __construct(TreeBuilderInterface $tree_builder) {
    $this->treeBuilder = $tree_builder;
  }

  /**
   * {@inheritdoc}
   */
  public static function create(ContainerInterface $container) {
    return new static(
      $container->get('token.tree_builder')
    );
  }

  /**
   * {@inheritdoc}
   */
  public function getFormId() {
    return 'me_admin_settings_form';
  }

  /**
   * {@inheritdoc}
   */
  protected function getEditableConfigNames() {
    return ['me.settings'];
  }

  public function buildForm(array $form, FormStateInterface $form_state) {
    $form = [];
    $theme = '';
    $form['me_alias'] = [
      '#type' => 'textfield',
      '#title' => t("'Me' Alias"),
      '#description' => t('The alias to use to represent the current users uid.'),
      '#default_value' => me_variable_get('me_alias'),
      '#required' => TRUE,
    ];

    // The theme_token_tree_link really only works if the token_types variable
    // is available.
    $info = token_theme();

    if (isset($info['token_tree_link']['variables']['token_types'])) {
      $theme = 'token_tree_link';
    }
    else {
      $theme = 'token_tree';
    }

    $form['me_token_help'] = [
    '#theme' => $theme,
    '#token_types' => array($instance['entity_type']),
    ];

    $form['me_case_insensitive'] = [
      '#type' => 'checkbox',
      '#title' => t('Case Insensitive Alias Checking'),
      '#description' => t('When checked, "Me" will be matched the same as "me", "ME", and "mE".'),
      '#default_value' => me_variable_get('me_case_insensitive'),
    ];

    $form['me_rewrite_link'] = [
      '#type' => 'checkbox',
      '#title' => t('Rewrite links generated by the drupal menu system'),
      '#description' => t('When checked, links output by the drupal menu system will replace uid with the me alias.'),
      '#default_value' => me_variable_get('me_rewrite_link'),
    ];

    $form['me_user_override'] = [
      '#type' => 'checkbox',
      '#title' => t('Allow users to turn off me for their account'),
      '#default_value' => me_variable_get('me_user_override'),
    ];

    $form['me_redirect'] = [
      '#type' => 'checkbox',
      '#title' => t('Redirect to uid'),
      '#description' => t('When checked, perform a redirect so the users uid is shown in the address bar instead of the me alias.'),
      '#default_value' => me_variable_get('me_redirect'),
    ];

    $form['me_redirect_anonymous'] = [
      '#type' => 'textfield',
      '#title' => t('Redirect anonymous users'),
      '#description' => t('When this is non-empty, anonymous users will be redirected to the specified drupal path.'),
      '#default_value' => me_variable_get('me_redirect_anonymous'),
    ];

    $access = \Drupal::currentUser()->hasPermission('use PHP for me alias paths');
    $path_rule = me_variable_get('me_path_rule');
    $paths = me_variable_get('me_paths');

    if ($path_rule == ME_PATH_PHP && !$access) {
      $form['me_paths_settings'] = [];
      $form['me_paths_settings']['me_path_rule'] = [
        '#type' => 'value',
        '#value' => $path_rule,
      ];
      $form['me_paths_settings']['me_paths'] = [
        '#type' => 'value',
        '#value' => $paths,
      ];
    }
    else {
      $options = [
        ME_PATH_EXCLUDE => t('Use me alias on every path except the listed paths.'),
        ME_PATH_INCLUDE => t('Use me alias only on the listed paths.'),
      ];
      $description = t("Enter one path per line as Drupal paths. The '*' character is a wildcard. Example paths are %blog for the blog page and %blog-wildcard for every personal blog. %front is the front page.", [
        '%blog' => 'blog',
        '%blog-wildcard' => 'blog/*',
        '%front' => '<front>',
      ]);

      if ($access) {
        $options[ME_PATH_PHP] = t('Use me alias if the following PHP code returns <code>TRUE</code> (PHP-mode, experts only).');
        $description .= ' ' . t('If the PHP-mode is chosen, enter PHP code between %php. Note that executing incorrect PHP-code can break your Drupal site.', [
          '%php' => '<?php ?>'
          ]);
      }

      $form['me_paths_settings']['me_path_rule'] = [
        '#type' => 'radios',
        '#title' => t('Use me alias on specific paths'),
        '#options' => $options,
        '#default_value' => $path_rule,
      ];

      $form['me_paths_settings']['me_paths'] = [
        '#type' => 'textarea',
        '#title' => t('Paths'),
        '#default_value' => $paths,
        '#description' => $description . t('<p>NOTE: This option simply ensures that the browser address bar for these paths have the uid and not me. The me alias will still work for these paths. It will have no effect on specific uids in paths, but if the path includes the me alias, then me will be affected for those paths. This will only affect paths that me can already handle. It will not allow me to work for unknown paths.</p>'),
      ];
    }

    $form = parent::buildForm($form, $form_state);
    return $form;
  }

  public function validateForm(array &$form, \Drupal\Core\Form\FormStateInterface $form_state) {
  // If the token module is installed, we need to also allow a list of tokens
  // that are allowed to match against. We include all global tokens here, even though
  // some of them don't really make sense, but that is up to the end user.
    $token_list = [];
    $token_service = \Drupal::token();
    $tk_types = $token_service->getGlobalTokenTypes();
    $options = [
      'flat' => TRUE,
      'restricted' => FALSE,
      'depth' => 4,
    ];
    foreach ($tk_types as $type) {
      $tree = $this->treeBuilder->buildTree($type, $options);
      $token_list = array_merge($token_list, array_keys($tree));
    }
    if (preg_match('/[^a-zA-Z\:]/', $form_state->getValue(['me_alias'])) && !in_array($form_state->getValue(['me_alias']), $token_list)) {
      if (!empty($token_list)) {
        $message = t('The alias can only contain characters from a-z and A-Z, or one of the tokens specified in the "Replacement patterns for me alias" section.');
      }
      else {
        $message = t('The alias can only contain characters from a-z and A-Z.');
      }
      $form_state->setErrorByName('me_alias', $message);
    }
  }

  /**
   * {@inheritdoc}
   */
  public function submitForm(array &$form, FormStateInterface $form_state) {
    $config = $this->config('me.settings');

    foreach (Element::children($form) as $variable) {
      $config->set($variable, $form_state->getValue($form[$variable]['#parents']));
    }
    $config->save();

    if (method_exists($this, '_submitForm')) {
      $this->_submitForm($form, $form_state);
    }

    parent::submitForm($form, $form_state);
  }

}
?>
