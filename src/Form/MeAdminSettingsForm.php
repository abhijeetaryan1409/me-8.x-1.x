<?php

/**
 * @file
 * Contains \Drupal\me\Form\MeAdminSettingsForm.
 */

namespace Drupal\me\Form;

use Drupal\Core\Form\ConfigFormBase;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Render\Element;

class MeAdminSettingsForm extends ConfigFormBase {

  /**
   * {@inheritdoc}
   */
  public function getFormId() {
    return 'me_admin_settings_form';
  }

  /**
   * {@inheritdoc}
   */
  public function submitForm(array &$form, FormStateInterface $form_state) {
    $config = $this->config('me.settings');

    foreach (Element::children($form) as $variable) {
      $config->set($variable, $form_state->getValue($form[$variable]['#parents']));
    }
    $config->save();

    if (method_exists($this, '_submitForm')) {
      $this->_submitForm($form, $form_state);
    }

    parent::submitForm($form, $form_state);
  }

  /**
   * {@inheritdoc}
   */
  protected function getEditableConfigNames() {
    return ['me.settings'];
  }

  public function buildForm(array $form, \Drupal\Core\Form\FormStateInterface $form_state) {
    $form = [];

    $form['me_alias'] = [
      '#type' => 'textfield',
      '#title' => t("'Me' Alias"),
      '#description' => t('The alias to use to represent the current users uid.'),
      '#default_value' => me_variable_get('me_alias'),
      '#required' => TRUE,
    ];
    // @FIXME
    // theme() has been renamed to _theme() and should NEVER be called directly.
    // Calling _theme() directly can alter the expected output and potentially
    // introduce security issues (see https://www.drupal.org/node/2195739). You
    // should use renderable arrays instead.
    // 
    // 
    // @see https://www.drupal.org/node/2195739
    // $form['me_token_help'] = array(
    //     '#title' => t('Replacement patterns for me alias'),
    //     '#type' => 'fieldset',
    //     '#collapsible' => TRUE,
    //     '#collapsed' => TRUE,
    //     'help' => array(
    //       '#type' => 'markup',
    //       '#markup' => theme('token_tree')
    //     ),
    //   );

    $form['me_case_insensitive'] = [
      '#type' => 'checkbox',
      '#title' => t('Case Insensitive Alias Checking'),
      '#description' => t('When checked, "Me" will be matched the same as "me", "ME", and "mE".'),
      '#default_value' => me_variable_get('me_case_insensitive'),
    ];

    $form['me_rewrite_link'] = [
      '#type' => 'checkbox',
      '#title' => t('Rewrite links generated by the drupal menu system'),
      '#description' => t('When checked, links output by the drupal menu system will replace uid with the me alias.'),
      '#default_value' => me_variable_get('me_rewrite_link'),
    ];

    $form['me_user_override'] = [
      '#type' => 'checkbox',
      '#title' => t('Allow users to turn off me for their account'),
      '#default_value' => me_variable_get('me_user_override'),
    ];

    $form['me_redirect'] = [
      '#type' => 'checkbox',
      '#title' => t('Redirect to uid'),
      '#description' => t('When checked, perform a redirect so the users uid is shown in the address bar instead of the me alias.'),
      '#default_value' => me_variable_get('me_redirect'),
    ];

    $form['me_redirect_anonymous'] = [
      '#type' => 'textfield',
      '#title' => t('Redirect anonymous users'),
      '#description' => t('When this is non-empty, anonymous users will be redirected to the specified drupal path.'),
      '#default_value' => me_variable_get('me_redirect_anonymous'),
    ];

    $access = \Drupal::currentUser()->hasPermission('use PHP for me alias paths');
    $path_rule = me_variable_get('me_path_rule');
    $paths = me_variable_get('me_paths');

    if ($path_rule == ME_PATH_PHP && !$access) {
      $form['me_paths_settings'] = [];
      $form['me_paths_settings']['me_path_rule'] = [
        '#type' => 'value',
        '#value' => $path_rule,
      ];
      $form['me_paths_settings']['me_paths'] = [
        '#type' => 'value',
        '#value' => $paths,
      ];
    }
    else {
      $options = [
        ME_PATH_EXCLUDE => t('Use me alias on every path except the listed paths.'),
        ME_PATH_INCLUDE => t('Use me alias only on the listed paths.'),
      ];
      $description = t("Enter one path per line as Drupal paths. The '*' character is a wildcard. Example paths are %blog for the blog page and %blog-wildcard for every personal blog. %front is the front page.", [
        '%blog' => 'blog',
        '%blog-wildcard' => 'blog/*',
        '%front' => '<front>',
      ]);

      if ($access) {
        $options[ME_PATH_PHP] = t('Use me alias if the following PHP code returns <code>TRUE</code> (PHP-mode, experts only).');
        $description .= ' ' . t('If the PHP-mode is chosen, enter PHP code between %php. Note that executing incorrect PHP-code can break your Drupal site.', [
          '%php' => '<?php ?>'
          ]);
      }
      $form['me_paths_settings']['me_path_rule'] = [
        '#type' => 'radios',
        '#title' => t('Use me alias on specific paths'),
        '#options' => $options,
        '#default_value' => $path_rule,
      ];
      $form['me_paths_settings']['me_paths'] = [
        '#type' => 'textarea',
        '#title' => t('Paths'),
        '#default_value' => $paths,
        '#description' => $description . t('<p>NOTE: This option simply ensures that the browser address bar for these paths have the uid and not me. The me alias will still work for these paths. It will have no effect on specific uids in paths, but if the path includes the me alias, then me will be affected for those paths. This will only affect paths that me can already handle. It will not allow me to work for unknown paths.</p>'),
      ];
    }

    $form['#validate'] = ['me_admin_settings_form_validate'];

    $form = parent::buildForm($form, $form_state);

    // Quite a few options only have an affect on theme and menu rebuilds. We just do them here
    // to make sure the options have an instant effect.
    $form['#submit'][] = 'menu_rebuild';
    $form['#submit'][] = 'drupal_theme_rebuild';

    return $form;
  }

  public function validateForm(array &$form, \Drupal\Core\Form\FormStateInterface $form_state) {
    // If the token module is installed, we need to also allow a list of tokens
  // that are allowed to match against. We include all global tokens here, even though
  // some of them don't really make sense, but that is up to the end user.
    $token_list = [];
    //$token_list = array_map(create_function('$n', 'return "[$n]";'), array_keys(array_pop(token_info())));
    $tk_types = token_get_global_token_types();
    $options = [
      'flat' => TRUE,
      'restricted' => FALSE,
      'depth' => 4,
    ];
    foreach ($tk_types as $type) {
      $tree = token_build_tree($type, $options);
      $token_list = array_merge($token_list, array_keys($tree));
    }
    if (preg_match('/[^a-zA-Z\:]/', $form_state->getValue(['me_alias'])) && !in_array($form_state->getValue(['me_alias']), $token_list)) {
      if (!empty($token_list)) {
        $message = t('The alias can only contain characters from a-z and A-Z, or one of the tokens specified in the "Replacement patterns for me alias" section.');
      }
      else {
        $message = t('The alias can only contain characters from a-z and A-Z.');
      }
      $form_state->setErrorByName('me_alias', $message);
    }
  }

}
?>
